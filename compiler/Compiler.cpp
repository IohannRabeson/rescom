#include "Compiler.hpp"
#include "Configuration.hpp"
#include "Strings.hpp"

#include <filesystem>
#include <fstream>
#include <iterator>
#include <iostream>

namespace
{
    static constexpr char const* NamespaceForResourceData = "rescom";

    bool loadFile(std::filesystem::path const& filePath, std::vector<char>& buffer)
    {
        std::ifstream file{filePath, std::ios::binary};

        if (file.is_open())
        {
            buffer.assign(std::istreambuf_iterator<char>(file), {});

            return true;
        }

        std::cerr << "Unable to read '" << filePath << "'\n";
        return false;
    }
}

Compiler::Compiler(Configuration const& configuration)
: _configuration(configuration)
, _tabulation(configuration.tabulationSize, ' ')
{
}

std::string Compiler::tab(unsigned int count) const
{
    std::string result;

    result.reserve(count * _tabulation.size());

    for (auto i = 0u; i < count; ++i)
        result += _tabulation;

    return result;
}

CompilationResult Compiler::compile(std::ostream& output)
{
    writeFileHeader(output);
    writeResources(output);
    writeAccessFunction(output);
    writeFileFooter(output);

    return CompilationResult::Ok;
}

void Compiler::writeFileHeader(std::ostream& output)
{
    auto resourceFileStem = toUpper(_configuration.configurationFilePath.stem().generic_string());

    output << "// Generated by Rescom\n";
    output << "#ifndef RESCOM_GENERATED_FILE_" << resourceFileStem << "\n";
    output << "#define RESCOM_GENERATED_FILE_" << resourceFileStem << "\n";
    output << "#include <stdexcept>\n";
    output << "#include <iterator>\n";
    output << "#include <string>\n";

    output << "namespace " << NamespaceForResourceData << "\n{\n";

    output << tab() << "struct ResourceSlot\n"
           << tab() << "{\n"
           << tab(2) << "char const* const key;\n"
           << tab(2) << "char const* const buffer;\n"
           << tab(2) << "unsigned int const size;\n"
           << tab(2) << "constexpr ResourceSlot(char const* key, unsigned int size, char const* buffer) : key(key), buffer(buffer), size(size) {}\n"
           << tab() << "};\n";
}

void Compiler::writeFileFooter(std::ostream& output)
{
    auto resourceFileStem = toUpper(_configuration.configurationFilePath.stem().generic_string());

    output << "} // namespace " << NamespaceForResourceData << "\n";
    output << "#endif // RESCOM_GENERATED_FILE_" << resourceFileStem << "\n";
}

void Compiler::writeResource(Input const& input, std::vector<char> const& buffer, std::ostream& output)
{
    output << tab(2) << "{\"" << input.key << "\", " << input.size << ", " << "\"";

    output << std::hex;

    for (auto const c : buffer) {
        output << "\\x" << (int)c;
    }

    output << std::dec;
    output << "\" },\n";
}

/// Write the code to access to a specific resource.
/// The generated code uses the fact resources are ordered by their key to use a constexpr version of std::lower_bound and
///// keep the compilation time acceptable.
void Compiler::writeAccessFunction(std::ostream& output)
{
    output << "\n";
    output << "namespace details {\n";
    output << tab() << "constexpr bool compareSlot(ResourceSlot const& slot, char const * key) { return std::string_view(slot.key) < key; }\n";
    // Function lowerBound is an ugly copy-paste of https://en.cppreference.com/w/cpp/algorithm/lower_bound.
    // But I don't care, it's constexpr and it just works.
    output << "    template<class ForwardIt, class T, class Compare>\n"
              "    constexpr ForwardIt lowerBound(ForwardIt first, ForwardIt last, T const& value, Compare comp)\n"
              "    {\n"
              "        ForwardIt it;\n"
              "        typename std::iterator_traits<ForwardIt>::difference_type count, step;\n"
              "        count = std::distance(first, last);\n"
              "\n"
              "        while (count > 0) {\n"
              "            it = first;\n"
              "            step = count / 2;\n"
              "            std::advance(it, step);\n"
              "            if (comp(*it, value)) {\n"
              "                first = ++it;\n"
              "                count -= step + 1;\n"
              "            }\n"
              "            else\n"
              "                count = step;\n"
              "        }\n"
              "        return first;\n"
              "    }\n"
              "\n";

    if (_configuration.inputs.empty())
        output << "static constexpr ResourceSlot const NullResourceSlot{nullptr, 0u, nullptr};\n";

    output << "} // namespace details\n";

    if (_configuration.inputs.empty())
    {
        output << tab() << "inline constexpr ResourceSlot const& getResource(char const* key)\n"
               << tab() << "{\n"
               << tab(3) << "return details::NullResourceSlot;\n"
               << tab() << "}\n";    }
    else
    {
        output << tab() << "inline constexpr ResourceSlot const& getResource(char const* key)\n"
               << tab() << "{\n"
               << tab(2) << "auto it = details::lowerBound(std::begin(details::Slots), std::end(details::Slots), key, details::compareSlot);\n"
               << "\n"
               << tab(2) << "if (it == std::end(details::Slots))\n"
               << tab(3) << "throw std::range_error(\"invalid resource key\");\n"
               << "\n"
               << tab(2) << "return *it;\n"
               << tab() << "}\n";
    }
}

CompilationResult Compiler::writeResources(std::ostream& output)
{
    if (_configuration.inputs.empty())
        return CompilationResult::Ok;

    std::vector<char> buffer;

    buffer.reserve(1024 * 16);

    output << "namespace details {\n";
    output << tab() << "constexpr unsigned int const ResourcesCount = " << _configuration.inputs.size() << ";\n";
    output << tab() << "constexpr ResourceSlot const Slots[ResourcesCount] = \n";
    output << tab() << "{\n";
    for (auto const& input : _configuration.inputs)
    {
        if (!loadFile(input.filePath, buffer))
            return CompilationResult::Error;

        writeResource(input, buffer, output);
    }

    output << tab() << "};\n";
    output << "} // namespace details\n";

    return CompilationResult::Ok;
}